<aside>
💡 <b>이 장에서 설명하는 주제</b>
    ▪️ 왜 이 장이 여기에 있는가?<br>
    ▪️ 왜 튼튼한 구조에 대해 걱정하는가?<br>
    ▪️ 필드 정밀 조정<br>
    ▪️ 테이블 정밀 조정<br>
    ▪️ 결실한 관계 설정하기<br>
    ▪️ 이것이 전부인가?<br>

</aside>

# ✔️ 내용

---

# 필드 정밀 조정

필드는 데이터베이스에서 가장 기초적인 구조이기에 테이블을 전체적으로 정밀 조정하기 전에 최상의 모양이 되도록 해야 한다. 많은 경우에, 필드를 고치면 주어진 테이블에서 다수의 기존 문제들이 제거되고, 발생할 수 있는 잠재적인 문제들을 피할 수 있도록 한다.

## 이름에 포함된 것

필드는 속해있는 테이블 주제의 한 특성을 나타낸다. 필드에 적절한 이름을 부여하면 그것이 표현하는 특성을 식별할 수 있다. 애매하거나 모호하거나 불명확한 이름은 문제 발생의 분명한 신호가 되고, 필드의 목적이 분명히 검토되지 않음을 보여준다. 각 필드의 이름을 테스트하기 위해 다음의 점검 목록을 사용하자.<br>
<br><br>
- 이름이 설명적이고 전체 조직에서 의미 있는가?<br>
- 필드 이름이 명확하고 명료한가?<br>
- 필드 이름으로 두문자어(acronym) 또는 약어(abbreviation)를 사용하고 있는가?<br>
- 한 가지 이상의 특성을 암시적 또는 명시적으로 식별하는 이름을 사용하고 있는가?<br>

## 거친 모서리 다듬기

필드 이름을 정리했다면 필드 자체의 구조에 초점을 맞춰야 한다. 필드가 추가적인 작업을 필요로 하는지 여부를 파악하기 위해 다음의 점검 목록으로 테스트해보자.<br>
<br><br>
- 필드가 테이블 주제의 특별한 특성을 나타내는지 확인한다.<br>
- 필드가 단일 값을 가지고 있는지 확인한다.<br>
- 필드가 계산이나 연결 결과를 저장하지 않는지 확인한다.<br>
- 필드가 전체 데이터베이스에서 단 한 번만 나타나도록 한다.<br>

## 다중 부분 필드 해결하기

다중 부분과 다중 값 필드는 데이터 무결성을 깨뜨리므로, 문제 발생을 피하기 위해 이들을 해결할 필요가 있다. 테이블에서 다중 부분 필드를 식별했을 때, 그것이 저장하고 있는 값에 얼마나 많은 부분들이 있는지 파악하고, 가능한 작은 필드들로 분할하자.

# 테이블 정밀 조정

테이블은 SQL의 기초가 된다. 잘못 설계된 테이블은 데이터 무결성 문제를 일으키고, 따라서 다중 테이블 SQL 쿼리를 만들 때 어려움을 겪게 된다. 

## 이름에 포함된 것

테이블은 단일 주제를 나타내어야 한다. 만약  하나 이상의 주제를 나타낸다면 더 작은 테이블들로 분할되어야 한다. 다음의 점검 목록에 의해 테이블 이름이 정상적인지 확인하자.<br>
<br><br>
- 이름이 고유하고 전체 조직에서 의미가 있을 만큼 충분히 설명적인가?<br>
- 이름이 정확하고 명확하고 모호하지 않게 테이블의 주제를 식별하는가?<br>
- 이름이 물리적 특성을 나타내는 단어를 포함하는가?<br>
- 테이블 이름으로 두문자어나 약어를 사용했는가?<br>
- 암시적 또는 명시적으로 하나 이상의 주제를 식별하는 이름을 사용했는가?<br>

## 튼튼한 구조 확인하기

이제 테이블 구조에 초점을 맞춰보자. 테이블이 적절하게 설계되어 효율적으로 데이터를 저장하고 정확한 정보를 추출할 수 있도록 하는 것은 반드시 필요하다. 테이블 구조가 튼튼한지 확인하기 위해 다음의 점검 목록을 사용하자.<br>
<br><br>
- 테이블이 단일 주제를 나타내는지 확인한다.<br>
- 각 테이블이 주 키를 가지고 있음을 확인한다.<br>
- 테이블이 다중 부분 또는 다중 값 필드를 포함하지 않는지 확인한다.<br>
- 테이블에 계산된 필드가 없는지 확인한다.<br>
- 테이블에 불필요한 이중(duplicate) 필드가 없는지 확인한다.<br>

## 식별하는 것은 키이다

기본 키는 테이블 내에서 가장 중요한 키이다. 이것이 테이블 내의 각 레코드를 유일하게 식별하고 데이터베이스 전체에서 테이블을 공식적으로 구별하기 때문이다. 이것은 또 한 쌍의 테이블 사이의 관계를 설정하기도 한다. 따라서 다음의 점검 목록을 사용하여 데이터베이스 내의 기본 키들이 정상적인지 파악해보자.<br>
<br><br>
- 필드가 테이블 내의 각 레코드를 유일하게 식별하는가?<br>
- 필드가 고유한 값을 가지는가?<br>
- 필드가 미지의 값을 포함할 수 있는가?<br>
- 필드의 값이 선택적일 수 있는가?<br>
- 다중 부분 필드인가?<br>
- 필드의 값이 언젠가 수정될 수 있는가?<br>

# 삭제 규칙 설정하기

삭제 규칙은 일대일 관계의 '주' 테이블의 레코드 또는 일대다 관계의 '일' 측 테이블의 레코드를 삭제하도록 요청할 때 어떤 일이 발생하는지를 나타낸다. 이 규칙을 설정함으로써 '고아(orphaned)' 레코드를 방지할 수 있다. 이때, 고아 레코드는 일대일 관계에서 '주' 테이블의 연관된 레코드를 가지지 못하는 '종속' 테이블 내의 레코드, 또는 일대다 관계에서 '일' 측 테이블의 연관된 레코드를 가지지 못하는 '다' 측 테이블 내의 레코드를 말한다.<br><br>

관계에 대해 제약(restrict)과 연속(cascade)이라는 두 종류의 삭제 규칙을 지정할 수 있다.<br><br>

- 제약 삭제 규칙은 일대일 관계의 '종속' 테이블 또는 일대다 관계의 '다' 측 테이블에 연관된 레코드가 있을 때 요청받는 레코드를 삭제하지 못하도록 한다. 요청받은 레코드를 삭제하기 전에 연관된 레코드를 먼저 삭제해야만 한다.<br>
- 연속 삭제 규칙이 강제로 적용될 때, 일대일 관계의 '종속' 테이블 또는 일대다 관계의 '다' 측 테이블의 연관된 레코드 뿐만 아니라 요청받은 레코드까지 삭제할 수 있다.<br>

# 결실한 관계 설정하기

우리는 첫 번째 테이블의 레코드가 두 번째 테이블의 레코드와 어떤 방법으로든 연관되면 한 쌍의 테이블 사이에 관계가 존재한다는 것을 배웠다. 또 관계 자체는 일대일, 일대다, 다대다라는 세 종류 중 하나로 지정될 수 있다는 것도 배웠다. 또 각 종류의 관계는 특별한 방법으로 설정된다는 것도 배웠다.<br>

## 참여 종류 설정하기

한 쌍의 테이블 사이에 관계를 설정할 때 각 테이블은 특별한 방법으로 참여한다. 주어진 테이블에 할당되는 참여 종류(type of participation)는 다른 테이블에 레코드를 삽입하기 전에 그 테이블에 레코드가 있어야 하는지 여부를 결정한다. 참여 종류 두 가지는 다음과 같다.<br>
<br><br>
- 강제적: 다른 테이블에 레코드를 입력하기 전에, 이 테이블에 적어도 하나의 레코드가 반드시 있어야 한다.<br>
- 선택적: 다른 테이블에 레코드를 입력하기 전에, 이 테이블에 어떤 레코드가 있어야 할 필요가 없다.<br>

## 참여 수준 설정하기

어떻게 각 테이블이 관계에 참여할 지 결정했기에 이제 각 테이블이 어느 수준으로 참여할 지를 생각해야 한다. 이것은 다른테이블의 단일 레코드에 연관될 수 있는 한 테이블의 최소 및 최대 레코드 수를 파악함으로써 수행된다. 이 작업을 테이블의 참여 수준(degree of participation)을 식별한다고 한다.<br>
<br>
데이터베이스 내의 다양한 테이블들을 위해 선택하는 참여 수준은 조직이 데이터를 어떻게 보고 사용하는 지에 크게 의존한다.<br>